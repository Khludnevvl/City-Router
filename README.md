## City-Router

---

Транспортный справочник, использующий JSON запросы для построения автобусных маршрутов, нахождения кратчайших путей, построение визуальной карты.

Для промежуточной сериализации используется protobuf. 

### Использование: 

Для работы необходимо установить [protobuf](https://github.com/protocolbuffers/protobuf/tree/master/src)

> Чтобы CMake нашел пакет protobuf, необхдимо при сборке указать ключ  **-DCMAKE_PREFIX_PATH=/path/to/protobuf/package** 

Программа имеет 2 варианта запуска.

1. make_base < input_file > // **Запрос на построение базы. Входной файл должен быть формата JSON (см. ниже).**

2. process_requsts < input_file > < output_file > // **Обработка запросов, введенных в input_file (формат запросов см.ниже). Результат записывается в output_file в формате JSON.**

### Формат запроса на построение базы (make_base): 

---

Файл запроса должен быть словарем JSON с обязательными ключами:
* serialization_settings // **Словарь с настройками сериализации (в данный момент доступен только ключ file).**
   * file // **Указывает файл для сериализации базы.**

* routing_settings // **Словарь с настройками маршрута.**
   * bus_wait_time // **Время ожидания автобуса.**
   * bus_velocity // **Средняя скорость автобуса.**
* base_requests // **Массив, содержащий основные запросы на создание базы.**
*Каждый запрос - Словарь с определенными ключами:*
   * type // **Тип запроса (доступны только Bus и Stop. Специфика каждого указана ниже).**
   * *Специфичные ключи для каждого запроса*

---
##### Bus запрос:

* name // **Название маршрута.**
* stops // **Массив названий остановок.**
* is_roadtrip // **Bool. Является ли маршрут кольцевым.**

##### Stop запрос:

* name // **Название остановки.**
* latitude // **Широта.**
* longitude // **Долгота.**
* road_distances // **Словарь расстояний, где ключ - название остановки, значение - расстояние от добавляемой остановки.**
---
* render_settings // **Словарь с настройками визуализации карты (используется SVG).**
   * width // **Ширина карты в пикселях. Вещественное число от 0 до 100000.**
   * height // **Высота карты в пикселях. Вещественное число от 0 до 100000.**
   * padding // **Отступ краёв карты от границ SVG-документа. Вещественное число не меньше 0 и меньше min(width, height)/2.**
   * stop_radius //  **радиус окружностей, которыми обозначаются остановки. Вещественное число в диапазоне от 0 до 100000.**

   * line_width // **Толщина линий, которыми рисуются автобусные маршруты. Вещественное число в диапазоне от 0 до 100000.**
   * bus_label_font_size  // **Размер текста, которым написаны названия автобусных маршрутов. Целое число в диапазоне от 0 до 100000.**
   * bus_label_offset // **Смещение надписи с названием маршрута относительно координат конечной остановки на карте. Массив из двух элементов типа double. Задаёт значения свойств dx и dy SVG-элемента < text >. Элементы массива — числа в диапазоне от –100000 до 100000.**

   * stop_label_font_size // **Размер текста, которым отображаются названия остановок. Целое число в диапазоне от 0 до 100000.**
   * stop_label_offset // **Смещение названия остановки относительно её координат на карте. Массив из двух.**
   * underlayer_color // **Цвет подложки под названиями остановок и маршрутов. Формат хранения цвета будет ниже.**
   * underlayer_width // **Толщина подложки под названиями остановок и маршрутов. Задаёт значение атрибута stroke-width элемента < text >. Вещественное число в диапазоне от 0 до 100000.**
   * color_palette // **Цветовая палитра. Непустой массив.**

Цвет можно указать:

1. *В виде строки, например, "red" или "black";*
2. *В массиве из трёх целых чисел диапазона [0, 255]. Они определяют r, g и b компоненты цвета в формате svg::Rgb. Цвет [255, 16, 12] нужно вывести как rgb(255, 16, 12);**
3. *В массиве из четырёх элементов: три целых числа в диапазоне от [0, 255] и одно вещественное число в диапазоне от [0.0, 1.0]. Они задают составляющие red, green, blue и opacity цвета формата svg::Rgba. Цвет, заданный как [255, 200, 23, 0.85], должен быть выведен как rgba(255, 200, 23, 0.85).*
---

##### Пример запроса на создание базы указан в файле "make_base_example.json"

---

### Формат запроса на получение информации из базы (process_base):

Файл запроса должен быть словарем JSON с обязательными ключами:

* serialization_settings // **Словарь с настройками сериализации (в данный момент доступен только ключ file).**
    * file // **Указывает файл для десериализации.**
* stat_requests // **Массив с основными запросами.**
*Каждый запрос - Словарь с определенными ключами:*
    * id // **Id запроса.**
    * type // **Тип запроса. Доступны: Route, Map, Stop, Bus. Ниже о каждом из них.**
    * *Специфичные ключи для каждого запроса*
##### Специфичные ключи для запросов:

---
Route //  **Запрос для построение кратчайшего маршрута между остановками**

* from // **Название остановки начала.**
* to // **Название конечной остановки.**

---
Map // **Запрос на визуализацию карты всех маршрутов.**

*Нет специфичных ключей*.

--- 

Stop // **Вывод информации об остановке.**

* name // **Название искомой остановки.**

---

Bus // **Вывод информации о маршруте.**

* name // **Название искомого маршрута**

---
##### Пример запроса на получение информации из базы указан в файле "process_requests_example.json"
---

### Формат ответа на запрос получения информации:

На каждый запрос массива stat_requests в выходном JSON-массиве должен содержаться ответ в виде словаря с обязательным ключом request_id, значение которого равно id соответствующего запроса. В словаре могут быть и другие ключи, специфичные для конкретного типа ответа.

---

#### Ответ на Bus запрос:

Словарь с ключами:

* curvature // **Кривизна маршрута. Вещественное число > 1.**
* route_lenght // **Длина маршрута.**
* stop_count // **Количество остановок.**
* unique_stop_count // **Количество уникальных остановок.**
*Если нет маршрута с указанным названием, ответ имеет вид -*
* "error_message": "not found"

#### Ответ на Stop запрос:

Словарь с ключами:

* buses // **Массив названий автобусных маршрутов, проходящих через эту остановку. Названия маршрутов отсортированы в лексикографическом порядке.**

*Если нет остановки с указанным названием, ответ имеет вид -*
* "error_message": "not found"

#### Ответ на Route запрос: 

* total_time // **Суммарное время в минутах, которое требуется для прохождения маршрута.**
* items // **Список элементов маршрута, каждый из которых описывает непрерывную активность пассажира, требующую временных затрат.Каждый элемент является словарем. А именно элементы маршрута бывают двух типов:**

    * wait // **Подождать нужное количество минут (всегда bus_wait_time) на указанной остановке.**

    * bus // **Проехать span_count остановок (перегонов между остановками) на автобусе bus, потратив указанное количество минут.**


#### Ответ на Map запрос:

   * map // **Карта выводится, как строка SVG формата.**

---

**Пример ответа на запрос указан в файле "output_example.json"**

---

### Минимальная версия языка C++17

---

### Стек технологий:

   [protobuf 3.18](https://github.com/protocolbuffers/protobuf/tree/master/src)

   [CMake 3.10](https://cmake.org/)

---